<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notepad</title>
    <!-- Google Fonts for Sleek Design -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --green-user: #4CAF50;
            --blue-user: #2196F3;
            --background-color: #f7f7f7;
            --card-background: #ffffff;
            --text-color: #333;
            --secondary-color: #666;
            --danger-color: #f44336;
            --success-color: #00bcd4;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Poppins', sans-serif;
        }

        body, html {
            height: 100%;
            overflow: hidden;
        }

        /* --- Global App Layout --- */
        #app-container {
            /* Initial state handled by JS */
            height: 100vh;
            display: grid;
            grid-template-rows: 50px 1fr;
            background-color: var(--background-color);
        }

        /* --- Header/Navigation --- */
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            background-color: var(--card-background);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 20; /* Ensures header is clickable */
            position: relative;
        }

        #header-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-color);
        }

        #header-actions {
            display: flex;
            gap: 15px;
        }

        .header-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--secondary-color);
            transition: color 0.2s;
            line-height: 1;
        }

        .header-btn:hover {
            color: var(--text-color);
        }

        /* --- Main Content Area (Swipe/Flashcard) --- */
        #main-content {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
            z-index: 10; /* Set below header */
        }

        .flashcard-stack {
            width: 100%;
            max-width: 400px;
            height: 100%;
            max-height: 600px;
            position: relative;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            padding: 25px;
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: grab;
            user-select: none;
        }

        .flashcard-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .flashcard-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color);
            word-wrap: break-word;
            max-width: 80%;
        }

        .flashcard-description {
            font-size: 1rem;
            color: var(--secondary-color);
            flex-grow: 1;
            overflow-y: auto;
            max-height: calc(100% - 150px);
            line-height: 1.6;
        }

        .flashcard-footer {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 10px;
            border-top: 1px solid #eee;
            margin-top: 15px;
        }

        .swipe-btns {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 5;
        }

        .swipe-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 1.8rem;
            color: var(--card-background);
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: transform 0.2s, opacity 0.2s;
        }

        .swipe-btn:active {
            transform: scale(0.9);
        }

        #like-btn { background-color: var(--green-user); }
        #discard-btn { background-color: var(--danger-color); }

        .new-tag {
            background-color: var(--success-color);
            color: white;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .like-indicator {
            font-size: 1.2rem;
            color: var(--danger-color);
            cursor: pointer;
        }

        /* User Color Coding */
        .card-green { border-left: 8px solid var(--green-user); }
        .card-blue { border-left: 8px solid var(--blue-user); }
        .user-tag {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 5px;
            font-weight: 600;
        }
        .user-tag-green { background-color: rgba(76, 175, 80, 0.2); color: var(--green-user); }
        .user-tag-blue { background-color: rgba(33, 150, 243, 0.2); color: var(--blue-user); }

        /* --- Modals (Profile, Add Note, Trash) --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--card-background);
            margin: auto;
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 400px;
            position: relative;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .modal-close:hover,
        .modal-close:focus {
            color: var(--text-color);
            text-decoration: none;
            cursor: pointer;
        }

        h2 { margin-bottom: 20px; color: var(--text-color); font-weight: 600; text-align: center;}

        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            margin: 8px 0 15px 0;
            display: inline-block;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 1rem;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        .modal-btn {
            background-color: var(--green-user);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        .modal-btn:hover {
            background-color: #45a049;
        }

        /* Profile Selection */
        .profile-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .profile-card {
            padding: 20px;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
            width: 120px;
            border: 3px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }

        .profile-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }

        .profile-card-green { background-color: rgba(76, 175, 80, 0.1); border-color: var(--green-user); }
        .profile-card-blue { background-color: rgba(33, 150, 243, 0.1); border-color: var(--blue-user); }

        .profile-card p {
            font-weight: 600;
            margin-top: 10px;
        }
        .profile-card-green p { color: var(--green-user); }
        .profile-card-blue p { color: var(--blue-user); }
        .profile-icon { font-size: 2.5rem; }

        /* Trash List */
        #trash-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .trash-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .trash-item:last-child { border-bottom: none; }
        .trash-item-title { font-weight: 500; font-size: 0.95rem; }
        .recover-btn {
            background: none;
            border: none;
            color: var(--success-color);
            cursor: pointer;
            font-size: 1.1rem;
        }

        /* Import/Export */
        #import-export-modal textarea {
            height: 150px;
        }
        #import-btn { background-color: var(--blue-user); margin-top: 10px;}
        #export-btn { background-color: var(--secondary-color); margin-bottom: 15px;}
        #import-btn:hover { background-color: #1a7bbd; }
        #export-btn:hover { background-color: #555; }

        /* Chat Box */
        #chat-box-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
        }
        #chat-toggle-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--blue-user);
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: background-color 0.2s;
        }
        #chat-toggle-btn:hover { background-color: #1a7bbd; }

        #chat-window {
            display: none;
            width: 300px;
            height: 400px;
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: absolute; /* Position relative to container */
            bottom: 0;
            right: 0;
        }
        #chat-messages {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
        }
        .chat-message {
            margin-bottom: 8px;
            padding: 5px 10px;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .chat-message-system { background-color: #e0f7fa; color: #00838f; margin-left: auto; }
        #chat-input-container {
            display: flex;
            padding: 10px;
        }
        #chat-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px 0 0 6px;
            border-right: none;
        }
        #chat-send-btn {
            padding: 8px 12px;
            background-color: var(--blue-user);
            color: white;
            border: none;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            font-size: 1rem;
        }

        /* --- Mobile Responsiveness (Sleek/Synchronized) --- */
        @media (max-width: 600px) {
            #main-content {
                padding: 10px;
            }
            .flashcard-stack {
                max-height: 80vh;
            }
            .swipe-btns {
                gap: 20px;
                bottom: 15px;
            }
            .swipe-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            #chat-window {
                width: 90vw;
                height: 300px;
                right: 5vw;
                bottom: 10px;
            }
        }

    </style>
</head>
<body>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        // ADDED AUTH IMPORTS
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import { getFirestore, collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

        // Global variables available in the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyCgWmuOquxwwHCG2u6FNZrb-zrBics3HWk",
            authDomain: "notes-d7918.firebaseapp.com",
            projectId: "notes-d7918",
            storageBucket: "notes-d7918.firebasestorage.app",
            messagingSenderId: "136757169437",
            appId: "1:136757169437:web:809c9df7ff5aca5ea6e5f4",
            measurementId: "G-H54E8JGDFL"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app); // INITIALIZE AUTH

        // --- MANDATORY AUTHENTICATION SETUP ---
        async function authenticateUser() {
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase authentication failed:", error);
            }
        }
        authenticateUser();
        // ----------------------------------------

        // Export Firebase references for global use in the main script block
        window.firebaseRefs = {
            db,
            auth, // EXPORT AUTH
            onAuthStateChanged, // EXPORT onAuthStateChanged
            collection,
            getDocs,
            addDoc,
            updateDoc,
            deleteDoc,
            doc,
            query,
            where,
            onSnapshot,
            serverTimestamp,
            appId
        };
    </script>

    <!-- 1. Profile Selection Screen (Initial Entry) -->
    <div id="profile-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Select Profile</h2>
            <p style="text-align: center; margin-bottom: 20px; color: var(--secondary-color);">Choose your note color code.</p>
            <div class="profile-selection">
                <div class="profile-card profile-card-green" onclick="selectProfile('green')">
                    <span class="profile-icon">🟢</span>
                    <p>Green</p>
                </div>
                <div class="profile-card profile-card-blue" onclick="selectProfile('blue')">
                    <span class="profile-icon">🔵</span>
                    <p>Blue</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Main Application Container -->
    <div id="app-container" style="display: none;"> <!-- Hidden until profile is selected -->
        <!-- Header -->
        <header id="header">
            <span id="header-title">NOTEPAD</span>
            <div id="header-actions">
                <button class="header-btn" title="Add Note" onclick="openAddNoteModal()">➕</button>
                <button class="header-btn" title="Import/Export" onclick="openImportExportModal()">📦</button>
                <button class="header-btn" title="Trash" onclick="openTrashModal()">🗑️</button>
            </div>
        </header>

        <!-- Main Content (Flashcard Swiping) -->
        <main id="main-content">
            <div class="flashcard-stack" id="flashcard-stack">
                <!-- Flashcards will be dynamically inserted here -->
                <div id="no-notes-placeholder" class="flashcard" style="align-items: center; justify-content: center; text-align: center; opacity: 1; transform: translate(0,0);">
                    <h2 style="margin-bottom: 0;">All Caught Up!</h2>
                    <p style="margin-top: 10px;">No active notes. Use ➕ to add a new one.</p>
                </div>
            </div>

            <!-- Swipe Buttons -->
            <div class="swipe-btns" id="swipe-btns" style="display: none;">
                <button class="swipe-btn" id="discard-btn" title="Discard" onclick="swipe('discard')">❌</button>
                <button class="swipe-btn" id="like-btn" title="Keep/Next" onclick="swipe('like')">❤️</button>
            </div>
        </main>
    </div>

    <!-- 3. Add Note Modal -->
    <div id="add-note-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('add-note-modal')">&times;</span>
            <h2>Add Note</h2>
            <input type="text" id="note-title" placeholder="Title" maxlength="50">
            <textarea id="note-description" placeholder="Description / Advice..."></textarea>
            <button class="modal-btn" onclick="saveNewNote()">Add Note</button>
        </div>
    </div>

    <!-- 4. Trash Modal -->
    <div id="trash-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('trash-modal')">&times;</span>
            <h2>Trashed Notes</h2>
            <div id="trash-list">
                <!-- Trashed notes will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- 5. Import/Export Modal -->
    <div id="import-export-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('import-export-modal')">&times;</span>
            <h2>Import / Export</h2>

            <button id="export-btn" class="modal-btn" onclick="exportNotes()">Export Notes</button>
            <p style="font-size: 0.9rem; margin: 10px 0;">Copy the data below:</p>
            <textarea id="export-data" readonly placeholder="Exported JSON will appear here..."></textarea>

            <p style="margin-top: 20px; font-size: 0.9rem;">Paste JSON to import:</p>
            <textarea id="import-data" placeholder="Paste your note JSON here..."></textarea>
            <button id="import-btn" class="modal-btn" onclick="importNotes()">Import Notes</button>
            <p id="import-status" style="margin-top: 10px; text-align: center;"></p>
        </div>
    </div>

    <!-- 6. Chat Box -->
    <div id="chat-box-container">
        <button id="chat-toggle-btn" onclick="toggleChatWindow()" title="Chat / Reminders">💬</button>
        <div id="chat-window" style="display: none;">
            <div id="chat-messages">
                <div class="chat-message chat-message-system">Welcome! Simple reminders here.</div>
            </div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Type a reminder..." onkeyup="if(event.key === 'Enter') sendChatMessage()">
                <button id="chat-send-btn" onclick="sendChatMessage()">Send</button>
            </div>
        </div>
    </div>

    <script>
        // Use the Firebase references exported from the module script
        let firebaseRefs = {};
        let db, auth, onAuthStateChanged, collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, onSnapshot, serverTimestamp, appId;

        const NOTES_COLLECTION = "flashcards";
        const TRASH_COLLECTION = "trash";
        const CHAT_COLLECTION = "chat";
        let currentUser = null; // 'green' or 'blue'
        let notes = [];
        let trashNotes = [];
        let currentNoteIndex = 0;
        let isAuthReady = false; // NEW STATE TO TRACK AUTH
        let unsubscribeNotes = null;
        let unsubscribeTrash = null;
        let unsubscribeChat = null;

        // --- Core Application Flow (Profile) ---

        /**
         * Generates the Firestore collection path for notes.
         * Using /artifacts/{appId}/public/data/collection_name for shared data.
         */
        const getCollectionPath = (collectionName) => {
            return `/artifacts/${appId}/public/data/${collectionName}`;
        };

        /**
         * Selects the user profile and starts the main app.
         * @param {string} profile - 'green' or 'blue'.
         */
        function selectProfile(profile) {
            currentUser = profile;
            localStorage.setItem('currentUser', profile);
            document.getElementById('profile-modal').style.display = 'none';
            document.getElementById('app-container').style.display = 'grid';
            // Start listening only after profile is selected and auth is ready
            if (isAuthReady) {
                initializeAppListeners();
            }
        }

        /**
         * Initial check on load to bypass profile if already set.
         */
        function initApp() {
            // 1. Wait for Firebase module to load and expose refs
            if (!window.firebaseRefs || !window.firebaseRefs.db) {
                 setTimeout(initApp, 100);
                 return;
            }

            firebaseRefs = window.firebaseRefs;
            ({ db, auth, onAuthStateChanged, collection, getDocs, addDoc, updateDoc, deleteDoc, doc, query, where, onSnapshot, serverTimestamp, appId } = firebaseRefs);

            currentUser = localStorage.getItem('currentUser');

            // 2. Wait for authentication to complete before proceeding
            onAuthStateChanged(auth, (user) => {
                isAuthReady = true;
                if (!user) {
                    console.error("User is not authenticated. Firestore operations will fail.");
                    return;
                }
                
                // If profile is already set, start listeners immediately
                if (currentUser) {
                    document.getElementById('app-container').style.display = 'grid';
                    initializeAppListeners();
                } else {
                    document.getElementById('profile-modal').style.display = 'flex';
                }
            });
        }

        // --- Firebase Listeners and Data Sync ---

        /**
         * Sets up real-time listeners for notes, trash, and chat.
         */
        function initializeAppListeners() {
            if (!isAuthReady) return; // Crucial check before accessing Firestore

            if (unsubscribeNotes) unsubscribeNotes();
            if (unsubscribeTrash) unsubscribeTrash();
            if (unsubscribeChat) unsubscribeChat();

            // Notes Listener
            const notesQuery = collection(db, getCollectionPath(NOTES_COLLECTION));
            unsubscribeNotes = onSnapshot(notesQuery, (snapshot) => {
                notes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => {
                    const dateA = a.createdAt || '';
                    const dateB = b.createdAt || '';
                    return dateB.localeCompare(dateA);
                });
                renderNotes();
            }, (error) => { console.error("Error fetching notes: ", error); });

            // Trash Listener
            const trashQuery = collection(db, getCollectionPath(TRASH_COLLECTION));
            unsubscribeTrash = onSnapshot(trashQuery, (snapshot) => {
                trashNotes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderTrashList();
            }, (error) => { console.error("Error fetching trash: ", error); });

            // Chat Listener
            const chatQuery = query(collection(db, getCollectionPath(CHAT_COLLECTION)));
            unsubscribeChat = onSnapshot(chatQuery, (snapshot) => {
                const chatMessages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                chatMessages.sort((a, b) => (a.timestamp && b.timestamp) ? (a.timestamp.toMillis() - b.timestamp.toMillis()) : 0);
                renderChatMessages(chatMessages);
            }, (error) => { console.error("Error fetching chat: ", error); });
        }


        // --- Flashcard & Swiping Logic ---

        /**
         * Renders the current stack of active flashcards.
         */
        function renderNotes() {
            const stack = document.getElementById('flashcard-stack');
            stack.innerHTML = '';
            currentNoteIndex = 0;

            if (notes.length === 0) {
                document.getElementById('no-notes-placeholder').style.display = 'flex';
                document.getElementById('swipe-btns').style.display = 'none';
                return;
            }

            document.getElementById('no-notes-placeholder').style.display = 'none';
            document.getElementById('swipe-btns').style.display = 'flex';

            notes.forEach((note, index) => {
                const card = document.createElement('div');
                card.className = `flashcard card-${note.user}`;
                card.id = `note-${note.id}`;
                // Stagger Z-index and position for stack effect
                card.style.zIndex = notes.length - index;
                card.style.transform = `translateY(${Math.min(index * 5, 20)}px) scale(${1 - Math.min(index * 0.05, 0.2)})`;
                card.dataset.noteId = note.id;
                card.dataset.index = index;

                card.innerHTML = `
                    <div class="flashcard-header">
                        <span class="flashcard-title">${note.title}</span>
                        <span class="user-tag user-tag-${note.user}">${note.user === 'green' ? 'GREEN' : 'BLUE'}</span>
                    </div>
                    <div class="flashcard-description">${note.description}</div>
                    <div class="flashcard-footer">
                        <div>
                            ${note.isNew ? '<span class="new-tag">NEW</span>' : ''}
                        </div>
                        <span class="like-indicator" data-liked="${note.liked || false}" onclick="toggleLike('${note.id}', event)">${note.liked ? '❤️' : '🤍'} ${note.likes || 0}</span>
                    </div>
                `;
                stack.appendChild(card);
            });
            setupSwipeGestures();
        }

        /**
         * Handles the Tinder-style swipe action (like/discard).
         * @param {string} action - 'like' or 'discard'.
         */
        async function swipe(action) {
            if (notes.length === 0 || !isAuthReady) return;

            const currentNote = notes[currentNoteIndex];
            const cardElement = document.getElementById(`note-${currentNote.id}`);

            if (!cardElement) return;

            // 1. Swiping Animation
            const translateX = action === 'like' ? '400%' : '-400%';
            const rotate = action === 'like' ? '10deg' : '-10deg';
            cardElement.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
            cardElement.style.transform = `${translateX} rotate(${rotate})`;
            cardElement.style.opacity = '0';

            // 2. Firebase Update
            try {
                // a. Mark as swiped (no longer "new")
                if (currentNote.isNew) {
                    await updateDoc(doc(db, getCollectionPath(NOTES_COLLECTION), currentNote.id), { isNew: false });
                }

                if (action === 'discard') {
                    // b. Move to Trash
                    const noteToTrash = { ...currentNote, trashedAt: new Date().toISOString() };
                    delete noteToTrash.id; // Remove client-side ID for new Firebase document
                    await addDoc(collection(db, getCollectionPath(TRASH_COLLECTION)), noteToTrash);
                    await deleteDoc(doc(db, getCollectionPath(NOTES_COLLECTION), currentNote.id));
                }
                // If 'like', only the `isNew` update runs. Data sync handles re-rendering.

                // 3. Increment index temporarily for next swipe action while waiting for Firestore sync
                currentNoteIndex = Math.min(currentNoteIndex + 1, notes.length - 1);

            } catch (error) {
                console.error("Error swiping note (check Firestore permissions):", error);
                // Revert animation on error
                cardElement.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                cardElement.style.transform = 'translate(0,0) rotate(0)';
                cardElement.style.opacity = '1';
                currentNoteIndex = 0; // Reset index
            }
        }

        /**
         * Sets up basic drag gestures for card swiping.
         */
        function setupSwipeGestures() {
            const cards = document.querySelectorAll('.flashcard-stack .flashcard');
            if (cards.length === 0) return;

            // Only apply gesture to the topmost card (index 0 in DOM, usually)
            const card = cards[cards.length - 1]; 
            if (!card) return;

            let isDragging = false;
            let startX, startY;
            const threshold = 100;

            if (card.dataset.index !== String(notes.length - 1)) return;

            card.addEventListener('mousedown', startDrag);
            card.addEventListener('touchstart', startDrag);

            function startDrag(e) {
                if (notes.length === 0) return;
                // Check if the click/touch originated from the like/discard buttons/indicators
                if (e.target.closest('.like-indicator') || e.target.closest('.swipe-btns')) return;

                isDragging = true;
                startX = e.clientX || e.touches[0].clientX;
                startY = e.clientY || e.touches[0].clientY;
                card.style.transition = 'none'; // Disable transition during drag
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
            }

            function drag(e) {
                if (!isDragging) return;
                const currentX = e.clientX || e.touches[0].clientX;
                const deltaX = currentX - startX;
                const rotation = deltaX / 20;

                card.style.transform = `translateX(${deltaX}px) rotate(${rotation}deg)`;
            }

            function endDrag(e) {
                if (!isDragging) return;
                isDragging = false;
                card.style.transition = 'transform 0.3s ease-out';
                const currentX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX) || startX;
                const deltaX = currentX - startX;

                // Determine swipe
                if (deltaX > threshold) {
                    swipe('like'); // Right swipe (Keep)
                } else if (deltaX < -threshold) {
                    swipe('discard'); // Left swipe (Discard)
                } else {
                    // Snap back
                    card.style.transform = `translate(0, 0) rotate(0deg)`;
                }

                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
            }
        }

        /**
         * Toggles the like status of a note.
         * @param {string} noteId
         * @param {Event} event
         */
        async function toggleLike(noteId, event) {
            event.stopPropagation();
            if (!isAuthReady) return; 
            
            const note = notes.find(n => n.id === noteId);
            if (!note) return;

            const newLikedState = !note.liked;
            const newLikesCount = newLikedState ? (note.likes || 0) + 1 : Math.max(0, (note.likes || 0) - 1);

            try {
                await updateDoc(doc(db, getCollectionPath(NOTES_COLLECTION), noteId), {
                    liked: newLikedState,
                    likes: newLikesCount,
                    isNew: false
                });
            } catch (error) {
                console.error("Error toggling like:", error);
            }
        }

        // --- CRUD / Modal Handlers ---

        function openAddNoteModal() {
            if (!currentUser) {
                console.warn('Please select a profile first.');
                return;
            }
            document.getElementById('note-title').value = '';
            document.getElementById('note-description').value = '';
            document.getElementById('add-note-modal').style.display = 'flex';
        }

        async function saveNewNote() {
            if (!isAuthReady) { console.error("Authentication not ready."); return; }
            
            const title = document.getElementById('note-title').value.trim();
            const description = document.getElementById('note-description').value.trim();

            if (!title || !description) {
                console.warn("Title and Description cannot be empty.");
                return;
            }

            try {
                // NOW THIS WRITE WILL SUCCEED
                await addDoc(collection(db, getCollectionPath(NOTES_COLLECTION)), {
                    title: title,
                    description: description,
                    user: currentUser,
                    liked: false,
                    likes: 0,
                    isNew: true,
                    createdAt: new Date().toISOString()
                });
                closeModal('add-note-modal');
            } catch (error) {
                console.error("Error saving note (check Auth state):", error);
            }
        }

        function renderTrashList() {
            const list = document.getElementById('trash-list');
            list.innerHTML = '';
            if (trashNotes.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: var(--secondary-color);">Trash is empty.</p>';
                return;
            }

            trashNotes.forEach(note => {
                const item = document.createElement('div');
                item.className = 'trash-item';
                item.innerHTML = `
                    <span class="trash-item-title">${note.title}</span>
                    <button class="recover-btn" title="Recover" onclick="recoverNote('${note.id}')">🔄</button>
                `;
                list.appendChild(item);
            });
        }

        async function recoverNote(trashId) {
            if (!isAuthReady) return; 
            
            const noteToRecover = trashNotes.find(n => n.id === trashId);
            if (!noteToRecover) return;

            try {
                // 1. Add back to active notes
                const recoveredNote = {
                    title: noteToRecover.title,
                    description: noteToRecover.description,
                    user: noteToRecover.user,
                    liked: noteToRecover.liked || false,
                    likes: noteToRecover.likes || 0,
                    isNew: true,
                    createdAt: noteToRecover.createdAt
                };
                await addDoc(collection(db, getCollectionPath(NOTES_COLLECTION)), recoveredNote);

                // 2. Delete from trash
                await deleteDoc(doc(db, getCollectionPath(TRASH_COLLECTION), trashId));
            } catch (error) {
                console.error("Failed to recover note:", error);
            }
        }

        function openTrashModal() {
            document.getElementById('trash-modal').style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // --- Import/Export ---

        function openImportExportModal() {
            document.getElementById('import-export-modal').style.display = 'flex';
            document.getElementById('export-data').value = '';
            document.getElementById('import-data').value = '';
            document.getElementById('import-status').innerText = '';
        }

        function exportNotes() {
            const exportArray = notes.map(note => ({
                title: note.title,
                description: note.description,
                user: note.user,
                liked: note.liked,
                likes: note.likes,
                isNew: note.isNew
            }));
            const exportString = JSON.stringify(exportArray, null, 2);
            document.getElementById('export-data').value = exportString;
            document.getElementById('import-status').style.color = 'var(--blue-user)';
            document.getElementById('import-status').innerText = 'Data prepared. Copy the JSON from the text area above.';
        }

        async function importNotes() {
            if (!isAuthReady) { console.error("Authentication not ready."); return; }
            
            const jsonInput = document.getElementById('import-data').value.trim();
            const status = document.getElementById('import-status');
            status.innerText = '';

            if (!jsonInput) {
                status.innerText = 'Paste JSON data to import.';
                status.style.color = 'var(--danger-color)';
                return;
            }

            try {
                const notesToImport = JSON.parse(jsonInput);
                if (!Array.isArray(notesToImport)) {
                    throw new Error("Data must be a JSON array of notes.");
                }

                let importedCount = 0;
                for (const note of notesToImport) {
                    if (note.title && note.description && (note.user === 'green' || note.user === 'blue')) {
                        await addDoc(collection(db, getCollectionPath(NOTES_COLLECTION)), {
                            title: note.title,
                            description: note.description,
                            user: note.user,
                            liked: note.liked || false,
                            likes: note.likes || 0,
                            isNew: true,
                            createdAt: new Date().toISOString()
                        });
                        importedCount++;
                    }
                }
                status.style.color = 'var(--green-user)';
                status.innerText = `Imported ${importedCount} notes!`;
                document.getElementById('import-data').value = '';

            } catch (error) {
                status.style.color = 'var(--danger-color)';
                status.innerText = 'Import failed. Check JSON format.';
                console.error("Import error:", error);
            }
        }

        // --- Chat Box Logic ---

        function toggleChatWindow() {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.style.display = chatWindow.style.display === 'flex' ? 'none' : 'flex';
        }

        async function sendChatMessage() {
            if (!isAuthReady) { console.error("Authentication not ready."); return; }
            
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message) return;

            try {
                // NOW THIS WRITE WILL SUCCEED
                await addDoc(collection(db, getCollectionPath(CHAT_COLLECTION)), {
                    text: message,
                    user: currentUser,
                    timestamp: serverTimestamp() // Use serverTimestamp for accuracy
                });
                input.value = '';
            } catch (error) {
                console.error("Error sending chat message (check Auth state):", error);
            }
        }

        function renderChatMessages(messages) {
            const chatMessagesDiv = document.getElementById('chat-messages');
            chatMessagesDiv.innerHTML = '';

            messages.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message chat-message-system`; 
                messageDiv.innerText = msg.text;
                chatMessagesDiv.appendChild(messageDiv);
            });

            // Scroll to the bottom
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }

        // --- Initialisation ---
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
